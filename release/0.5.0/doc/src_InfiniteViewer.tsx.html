<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/InfiniteViewer.tsx - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/daybrush.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="description" content="src/InfiniteViewer.tsx - Documentation"/>

</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h2 class="custom"><a href="https://github.com/daybrush/infinite-viewer" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><div class="search"><div class="input-area"><input type="text"/></div><button></button></div><ul class="classes"><li file="infiniteviewer" class="parent"><a href="InfiniteViewer.html">InfiniteViewer</a><h4><a href="InfiniteViewer.html#static members">Static Members</a></h4><ul class='static members'><li data-type='member'><a href="InfiniteViewer.html#.CLASS_NAME">CLASS_NAME</a></li><li data-type='member'><a href="InfiniteViewer.html#.EVENTS">EVENTS</a></li><li data-type='member'><a href="InfiniteViewer.html#.METHODS">METHODS</a></li><li data-type='member'><a href="InfiniteViewer.html#.OPTIONS">OPTIONS</a></li><li data-type='member'><a href="InfiniteViewer.html#.PROPERTIES">PROPERTIES</a></li></ul><h4><a href="InfiniteViewer.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="InfiniteViewer.html#destroy">destroy</a></li><li data-type='method'><a href="InfiniteViewer.html#getContainer">getContainer</a></li><li data-type='method'><a href="InfiniteViewer.html#getScrollHeight">getScrollHeight</a></li><li data-type='method'><a href="InfiniteViewer.html#getScrollLeft">getScrollLeft</a></li><li data-type='method'><a href="InfiniteViewer.html#getScrollTop">getScrollTop</a></li><li data-type='method'><a href="InfiniteViewer.html#getScrollWidth">getScrollWidth</a></li><li data-type='method'><a href="InfiniteViewer.html#getViewport">getViewport</a></li><li data-type='method'><a href="InfiniteViewer.html#scrollBy">scrollBy</a></li><li data-type='method'><a href="InfiniteViewer.html#scrollCenter">scrollCenter</a></li><li data-type='method'><a href="InfiniteViewer.html#scrollTo">scrollTo</a></li></ul><h4><a href="InfiniteViewer.html#events">Events</a></h4><ul class='events'><li data-type='event'><a href="InfiniteViewer.html#.event:abortPinch">abortPinch</a></li><li data-type='event'><a href="InfiniteViewer.html#.event:drag">drag</a></li><li data-type='event'><a href="InfiniteViewer.html#.event:dragEnd">dragEnd</a></li><li data-type='event'><a href="InfiniteViewer.html#.event:dragStart">dragStart</a></li><li data-type='event'><a href="InfiniteViewer.html#.event:pinch">pinch</a></li><li data-type='event'><a href="InfiniteViewer.html#.event:scroll">scroll</a></li></ul><h4><a href="InfiniteViewer.html#type definitions">Type Definitions</a></h4><ul class='type definitions'><li data-type='typddef'><a href="InfiniteViewer.html#.InfiniteViewerOptions">InfiniteViewerOptions</a></li><li data-type='typddef'><a href="InfiniteViewer.html#.OnAbortPinch">OnAbortPinch</a></li><li data-type='typddef'><a href="InfiniteViewer.html#.OnDrag">OnDrag</a></li><li data-type='typddef'><a href="InfiniteViewer.html#.OnDragEnd">OnDragEnd</a></li><li data-type='typddef'><a href="InfiniteViewer.html#.OnDragStart">OnDragStart</a></li><li data-type='typddef'><a href="InfiniteViewer.html#.OnPinch">OnPinch</a></li><li data-type='typddef'><a href="InfiniteViewer.html#.OnScroll">OnScroll</a></li></ul></li><li file="component" class="parent"><a href="eg.Component.html">eg.Component</a><h4><a href="eg.Component.html#static members">Static Members</a></h4><ul class='static members'><li data-type='member'><a href="eg.Component.html#.VERSION">VERSION</a></li></ul><h4><a href="eg.Component.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="eg.Component.html#hasOn">hasOn</a></li><li data-type='method'><a href="eg.Component.html#off">off</a></li><li data-type='method'><a href="eg.Component.html#on">on</a></li><li data-type='method'><a href="eg.Component.html#once">once</a></li><li data-type='method'><a href="eg.Component.html#trigger">trigger</a></li></ul></li></ul><ul class="global"><li file="global"  class="parent"><a href="global.html">Global</a><h4><a href="global.html#methods">Methods</a></h4><ul class='methods'><li data-type='method'><a href="global.html#isUndefined">isUndefined</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">src/InfiniteViewer.tsx</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Component from "@egjs/component";
import Dragger from "@daybrush/drag";
import { InjectResult } from "css-styled";
import { Properties } from "framework-utils";
import { camelize, IObject, addEvent, removeEvent, addClass } from "@daybrush/utils";
import { InfiniteViewerOptions, InfiniteViewerProperties, InfiniteViewerEvents } from "./types";
import { PROPERTIES, injector, CLASS_NAME } from "./consts";
import { measureSpeed, getDuration, getDestPos, minmax } from "./utils";

@Properties(PROPERTIES as any, (prototype, property) => {
    const attributes: IObject&lt;any> = {
        enumerable: true,
        configurable: true,
        get() {
            return this.options[property];
        },
    };
    const setter = camelize(`set ${property}`);
    if (prototype[setter]) {
        attributes.set = function(value) {
            this[setter](value);
        };
    } else {
        attributes.set = function(value) {
            this.options[property] = value;
        };
    }
    Object.defineProperty(prototype, property, attributes);
})
/**
 * @sort 1
 */
class InfiniteViewer extends Component {
    public options: InfiniteViewerOptions;
    private injectResult!: InjectResult;
    private scrollArea!: HTMLElement;
    private dragger!: Dragger;
    private loopX = 0;
    private loopY = 0;
    private offsetX = 0;
    private offsetY = 0;
    private scrollLeft = 0;
    private scrollTop = 0;
    private timer = 0;
    private dragFlag = false;
    /**
     * @sort 1
     */
    constructor(
        private container: HTMLElement,
        private viewport: HTMLElement,
        options: Partial&lt;InfiniteViewerOptions> = {},
    ) {
        super();
        this.options = {
            margin: 500,
            threshold: 100,
            zoom: 1,
            rangeX: [-Infinity, Infinity],
            rangeY: [-Infinity, Infinity],
            scrollArea: null,
            usePinch: false,
            pinchThreshold: 30,
            cspNonce: "",
            ...options,
        };
        this.scrollArea = this.options.scrollArea;
        this.init();
    }
    /**
     * Get Container Element
     */
    public getContainer(): HTMLElement {
        return this.container;
    }
    /**
     * Get Viewport Element
     */
    public getViewport(): HTMLElement {
        return this.viewport;
    }
    /**
     * Destroy elements, properties, and events.
     */
    public destroy(): void {
        this.off();
        this.dragger.unset();
        this.injectResult.destroy();
        removeEvent(this.container, "scroll", this.onScroll);

        this.dragger = null;
        this.injectResult = null;
        this.container = null;
        this.options = null;
    }
    /**
     * Gets the number of pixels that an element's content is scrolled vertically.
     * @param - Get absolute top position
     */
    public getScrollTop(isAbsolute?: boolean) {
        return (this.scrollTop + (this.loopY - 1) * this.margin - this.offsetY
            + (isAbsolute ? (-this.rangeY[0] + 1) * this.margin : 0)) / this.zoom;
    }
    /**
     * Gets the number of pixels that an element's content is scrolled vertically.
     * @param - Get absolute left position
     */
    public getScrollLeft(isAbsolute?: boolean) {
        return (this.scrollLeft + (this.loopX - 1) * this.margin - this.offsetX
            + (isAbsolute ? (-this.rangeX[0] + 1) * this.margin : 0)) / this.zoom;
    }
    /**
     * Gets measurement of the width of an element's content with overflow
     */
    public getScrollWidth() {
        return this.container.offsetWidth + this.margin * (this.rangeX[1] - this.rangeX[0] + 2);
    }
    /**
     * Gets measurement of the height of an element's content with overflow
     */
    public getScrollHeight() {
        return this.container.offsetHeight + this.margin * (this.rangeY[1] - this.rangeY[0] + 2);
    }

    /**
     * Scroll the element to the center
     */
    public scrollCenter() {
        const {
            offsetWidth: containerWidth,
            offsetHeight: containerHeight,
        } = this.container;
        const {
            offsetWidth: viewportWidth,
            offsetHeight: viewportHeight,
        } = this.viewport;
        const zoom = this.zoom;
        const left = -(containerWidth - viewportWidth * zoom) / 2;
        const top = -(containerHeight - viewportHeight * zoom) / 2;

        return this.scrollTo(left, top);
    }
    /**
     * Scrolls the container by the given amount.
     * @param deltaX
     * @param deltaY
     */
    public scrollBy(deltaX: number, deltaY: number) {
        const zoom = this.zoom;
        return this.scrollTo(this.getScrollLeft() * zoom + deltaX, this.getScrollTop() * zoom + deltaY);
    }
    /**
     * Scrolls the container to set of coordinates.
     * @param scrollLeft
     * @param scrollTop
     */
    public scrollTo(scrollLeft: number, scrollTop: number) {
        const {
            rangeX = [0, 0],
            rangeY = [0, 0],
            margin = 0,
        } = this;

        this.loopX = minmax(Math.floor((margin + scrollLeft) / margin), rangeX[0], rangeX[1]);
        this.loopY = minmax(Math.floor((margin + scrollTop) / margin), rangeY[0], rangeY[1]);
        this.offsetX = (this.loopX - 1) * margin - scrollLeft + this.scrollLeft;
        this.offsetY = (this.loopY - 1) * margin - scrollTop + this.scrollTop;

        this.render();
        /**
         * The `scroll` event fires when the document view or an element has been scrolled.
         * @memberof InfiniteViewer
         * @event scroll
         * @param {InfiniteViewer.OnScroll} - Parameters for the scroll event
         * @example
         * import InfiniteViewer from "infinite-viewer";
         *
         * const viewer = new InfiniteViewer(
         *   document.querySelector(".container"),
         *   document.querySelector(".viewport"),
         * ).on("scroll", () => {
         *   console.log(viewer.getScrollLeft(), viewer.getScrollTop());
         * });
         */
        this.trigger("scroll", {
            scrollLeft: this.getScrollLeft(),
            scrollTop: this.getScrollTop(),
        });
        return this;
    }
    public setZoom(zoom: number) {
        const viewport = this.viewport;
        const offsetWidth = viewport.offsetWidth;
        const offsetHeight = viewport.offsetHeight;
        const offsetZoom = (zoom - this.zoom);

        this.options.zoom = zoom;

        this.scrollBy(offsetWidth * offsetZoom / 2, offsetHeight * offsetZoom / 2);
        this.render();
    }
    private init() {
        // infinite-viewer(container)
        // viewport
        // children
        const container = this.container;

        addClass(container, CLASS_NAME);

        // vanilla
        if (!this.scrollArea) {
            this.scrollArea = document.createElement("div");

            const scrollArea = this.scrollArea;

            scrollArea.style.cssText += `position:absolute;top:0;left:0;`;
            container.insertBefore(scrollArea, container.firstChild);
        }
        this.injectResult = injector.inject(container, {
            nonce: this.options.cspNonce,
        });
        /**
         * the `dragStart` event fires when `touchstart` does occur.
         * @memberof InfiniteViewer
         * @event dragStart
         * @param {InfiniteViewer.OnDragStart} - Parameters for the `dragStart` event
         * @example
         * import InfiniteViewer from "infinite-viewer";
         *
         * const viewer = new InfiniteViewer(
         *   document.querySelector(".container"),
         *   document.querySelector(".viewport"),
         * ).on("dragStart", e => {
         *   console.log(e.inputEvent);
         * });
         */
        /**
         * the `drag` event fires when `touch` does occur.
         * @memberof InfiniteViewer
         * @event drag
         * @param {InfiniteViewer.OnDrag} - Parameters for the `drag` event
         * @example
         * import InfiniteViewer from "infinite-viewer";
         *
         * const viewer = new InfiniteViewer(
         *   document.querySelector(".container"),
         *   document.querySelector(".viewport"),
         * ).on("drag", e => {
         *   console.log(e.inputEvent);
         * });
         */
        /**
         * the `dragEnd` event fires when `touchend` does occur.
         * @memberof InfiniteViewer
         * @event dragEnd
         * @param {InfiniteViewer.OnDragEnd} - Parameters for the `dragEnd` event
         * @example
         * import InfiniteViewer from "infinite-viewer";
         *
         * const viewer = new InfiniteViewer(
         *   document.querySelector(".container"),
         *   document.querySelector(".viewport"),
         * ).on("dragEnd", e => {
         *   console.log(e.inputEvent);
         * });
         */
        /**
         * the `abortPinch` event fires when `pinch` event does not occur by dragging a certain area.
         * @memberof InfiniteViewer
         * @event abortPinch
         * @param {InfiniteViewer.OnAbortPinch} - Parameters for the abortPinch event
         * @example
         * import InfiniteViewer from "infinite-viewer";
         *
         * const viewer = new InfiniteViewer(
         *   document.querySelector(".container"),
         *   document.querySelector(".viewport"),
         *   {
         *     usePinch: true,
         *   }
         * ).on("abortPinch", e => {
         *   console.log(e.inputEvent);
         * });
         */
        /**
         * the `pinch` event fires when two points pinch the viewer
         * @memberof InfiniteViewer
         * @event pinch
         * @param {InfiniteViewer.OnPinch} - Parameters for the `pinch` event
         * @example
         * import InfiniteViewer from "infinite-viewer";
         *
         * const viewer = new InfiniteViewer(
         *   document.querySelector(".container"),
         *   document.querySelector(".viewport"),
         *   {
         *     usePinch: true,
         *   }
         * ).on("pinch", e => {
         *   console.log(e.zoom, e.inputEvent);
         * });
         */
        this.dragger = new Dragger(container, {
            container: document.body,
            events: ["touch"],
            dragstart: ({ inputEvent, datas }) => {
                inputEvent.preventDefault();
                this.pauseAnimation();
                this.dragFlag = false;

                datas.startEvent = inputEvent;
                return this.trigger("dragStart", {
                    inputEvent,
                });
            },
            drag: e => {
                const options = this.options;
                if (!options.usePinch || e.isPinch) {
                    this.trigger("drag", {
                        inputEvent: e.inputEvent,
                    });
                    measureSpeed(e);
                    this.scrollBy(-e.deltaX, -e.deltaY);
                } else if (!this.dragFlag &amp;&amp; e.movement > options.pinchThreshold) {
                    this.dragFlag = true;

                    this.trigger("abortPinch", {
                        inputEvent: e.datas.startEvent || e.inputEvent,
                    });
                }
            },
            dragend: e => {
                this.trigger("dragEnd", {
                    isDrag: e.isDrag,
                    isDouble: e.isDouble,
                    inputEvent: e.inputEvent,
                });
                this.startAnimation(e.datas.speed);
            },
            pinchstart: ({ inputEvent, datas }) => {
                inputEvent.preventDefault();
                this.pauseAnimation();
                datas.startZoom = this.zoom;
            },
            pinch: e => {
                // e.distance;
                // e.scale
                this.trigger("pinch", {
                    distance: e.distance,
                    scale: e.scale,
                    zoom: e.datas.startZoom * e.scale,
                    inputEvent: e.inputEvent,
                });
            },
        });
        const margin = this.margin;

        addEvent(container, "scroll", this.onScroll);
        this.render();
        this.move(margin, margin);
    }
    private render() {
        const {
            margin = 0,
            loopX,
            loopY,
            offsetX,
            offsetY,
            zoom = 1,
        } = this;
        const size = `calc(100% + ${margin * 2}px)`;
        const nextOffsetX = (1 - loopX) * margin + offsetX;
        const nextOffsetY = (1 - loopY) * margin + offsetY;

        this.scrollArea.style.cssText += `position:absolute;top:0;left:0;width:${size};height:${size};`;
        this.viewport.style.cssText = `transform-origin: 0 0;transform:translate(${nextOffsetX}px, ${nextOffsetY}px) scale(${zoom});`;
    }
    private move(scrollLeft: number, scrollTop: number) {
        const container = this.container;

        container.scrollLeft = scrollLeft;
        container.scrollTop = scrollTop;
    }
    private onScroll = () => {
        const container = this.container;
        const { scrollLeft, scrollTop } = container;
        const {
            margin = 0,
            threshold = 0,
            loopX,
            loopY,
            rangeX = [0, 0],
            rangeY = [0, 0],
        } = this;
        const endThreshold = margin * 2 - threshold;
        let nextLoopX = loopX;
        let nextLoopY = loopY;

        let nextScrollLeft = scrollLeft;
        let nextScrollTop = scrollTop;

        if (scrollLeft &lt; threshold) {
            if (nextLoopX > rangeX[0]) {
                nextScrollLeft = scrollLeft + margin;
                --nextLoopX;
            }
        } else if (scrollLeft > endThreshold) {
            if (nextLoopX &lt; rangeX[1]) {
                nextScrollLeft = scrollLeft - margin;
                ++nextLoopX;
            }
        }
        if (scrollTop &lt; threshold) {
            if (nextLoopY > rangeY[0]) {
                nextScrollTop = scrollTop + margin;
                --nextLoopY;
            }
        } else if (scrollTop > endThreshold) {
            if (nextLoopY &lt; rangeY[1]) {
                nextScrollTop = scrollTop - margin;
                ++nextLoopY;
            }
        }
        const isChangeScroll = this.scrollLeft !== nextScrollLeft || this.scrollTop !== nextScrollTop;
        const isChangeLoop = loopX !== nextLoopX || loopY !== nextLoopY;

        this.scrollLeft = nextScrollLeft;
        this.scrollTop = nextScrollTop;
        this.loopX = nextLoopX;
        this.loopY = nextLoopY;

        this.render();

        if (isChangeLoop || isChangeScroll) {
            this.trigger("scroll", {
                scrollLeft: this.getScrollLeft(),
                scrollTop: this.getScrollTop(),
            });
        }

        if (isChangeScroll) {
            this.move(nextScrollLeft, nextScrollTop);
        }
    }
    private startAnimation(speed: number[]) {
        if (!speed || (!speed[0] &amp;&amp; !speed[1])) {
            return;
        }
        const a = -0.0006;
        const easing = x => 1 - Math.pow(1 - x, 3);
        const duration = getDuration(speed, a);
        const destPos = getDestPos(speed, a);
        const startTime = Date.now();
        let prevTime = startTime;

        const next = () => {
            const now = Date.now();
            let t = now - startTime;

            if (duration &lt; t) {
                t = duration;
            }
            const ratio = easing(t / duration);
            const prevRatio = easing((prevTime - startTime) / duration);

            prevTime = now;

            this.scrollBy(
                -destPos[0] * (ratio - prevRatio),
                -destPos[1] * (ratio - prevRatio),
            );

            if (t >= duration) {
                return;
            }
            this.timer = requestAnimationFrame(next);
        };
        this.timer = requestAnimationFrame(next);
    }
    private pauseAnimation() {
        cancelAnimationFrame(this.timer);
    }
}

interface InfiniteViewer extends Component, InfiniteViewerProperties {
    // tslint:disable-next-line: max-line-length
    on&lt;T extends keyof InfiniteViewerEvents>(eventName: T, handlerToAttach: (event: InfiniteViewerEvents[T]) => any): this;
    on(eventName: string, handlerToAttach: (event: { [key: string]: any }) => any): this;
    on(events: { [key: string]: (event: { [key: string]: any }) => any }): this;
}

export default InfiniteViewer;
</code></pre>
        </article>
    </section>





<style>


nav li[file="src/infiniteviewer"]:after {
    display: none;
}
nav li[file="src/infiniteviewer"] h4, nav li[file="src/infiniteviewer"] ul {
    display: block;
}
</style>

</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/daybrush/jsdoc">JSDoc 0.3.7</a> on Sun Jul 12 2020 06:02:51 GMT+0900 (GMT+09:00) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/utils.min.js"></script>
<script src="scripts/search.js"></script>
<script src="scripts/custom.js"></script>
</body>
</html>
